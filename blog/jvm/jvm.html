<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


html {
	font-size: 19px;
}

html, body {
	margin: auto;
	background: #fefefe;
	-webkit-font-smoothing: antialiased;
}
body {
	font-family: "Vollkorn", Palatino, Times;
	color: #333;
	line-height: 1.4;
	text-align: justify;
}

#write {
	max-width: 960px;
	margin: 0 auto;
	margin-bottom: 2em;
	line-height: 1.53;
	padding-top: 40px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1100px;
	}
}

@media print {
	html {
		font-size: 13px;
	}
}

/* Typography
-------------------------------------------------------- */

#write>h1:first-child,
h1 {
	margin-top: 1.6em;
	font-weight: normal;
}

h1 {
	font-size:3em;
}

h2 {
	margin-top:2em;
	font-weight: normal;
}

h3 {
	font-weight: normal;
	font-style: italic;
	margin-top: 3em;
}

h1, 
h2, 
h3{
	text-align: center;
}

h2:after{
	border-bottom: 1px solid #2f2f2f;
    content: '';
    width: 100px;
    display: block;
    margin: 0 auto;
    height: 1px;
}

h1+h2, h2+h3 {
	margin-top: 0.83em;
}

p,
.mathjax-block {
	margin-top: 0;
	-webkit-hypens: auto;
	-moz-hypens: auto;
	hyphens: auto;
}
ul {
	list-style: square;
	padding-left: 1.2em;
}
ol {
	padding-left: 1.2em;
}
blockquote {
	margin-left: 1em;
	padding-left: 1em;
	border-left: 1px solid #ddd;
}
code,
pre {
	font-family: "Consolas", "Menlo", "Monaco", monospace, serif;
	font-size: .9em;
	background: white;
}
.md-fences{
	margin-left: 1em;
	padding-left: 1em;
	border: 1px solid #ddd;
	padding-bottom: 8px;
	padding-top: 6px;
	margin-bottom: 1.5em;
}

a {
	color: #2484c1;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
a img {
	border: none;
}
h1 a,
h1 a:hover {
	color: #333;
	text-decoration: none;
}
hr {
	color: #ddd;
	height: 1px;
	margin: 2em 0;
	border-top: solid 1px #ddd;
	border-bottom: none;
	border-left: 0;
	border-right: 0;
}
.ty-table-edit {
	background: #ededed;
    padding-top: 4px;
}
table {
	margin-bottom: 1.333333rem
}
table th,
table td {
	padding: 8px;
	line-height: 1.333333rem;
	vertical-align: top;
	border-top: 1px solid #ddd
}
table th {
	font-weight: bold
}
table thead th {
	vertical-align: bottom
}
table caption+thead tr:first-child th,
table caption+thead tr:first-child td,
table colgroup+thead tr:first-child th,
table colgroup+thead tr:first-child td,
table thead:first-child tr:first-child th,
table thead:first-child tr:first-child td {
	border-top: 0
}
table tbody+tbody {
	border-top: 2px solid #ddd
}

.task-list{
	padding:0;
}

.md-task-list-item {
	padding-left: 1.6rem;
}

.md-task-list-item > input:before {
	content: '\221A';
	display: inline-block;
	width: 1.33333333rem;
  	height: 1.6rem;
	vertical-align: middle;
	text-align: center;
	color: #ddd;
	background-color: #fefefe;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before{
	color: inherit;
}
.md-tag {
	color: inherit;
	font: inherit;
}
#write pre.md-meta-block {
	min-height: 35px;
	padding: 0.5em 1em;
}
#write pre.md-meta-block {
	white-space: pre;
	background: #f8f8f8;
	border: 0px;
	color: #999;
	
	width: 100vw;
	max-width: calc(100% + 60px);
	margin-left: -30px;
	border-left: 30px #f8f8f8 solid;
	border-right: 30px #f8f8f8 solid;

	margin-bottom: 2em;
	margin-top: -1.3333333333333rem;
	padding-top: 26px;
	padding-bottom: 10px;
	line-height: 1.8em;
	font-size: 0.9em;
	font-size: 0.76em;
	padding-left: 0;
}
.md-img-error.md-image>.md-meta{
	vertical-align: bottom;
}
#write>h5.md-focus:before {
	top: 2px;
}

.md-toc {
	margin-top: 40px;
}

.md-toc-content {
	padding-bottom: 20px;
}

.outline-expander:before {
	color: inherit;
	font-size: 14px;
	top: auto;
	content: "\f0da";
	font-family: FontAwesome;
}

.outline-expander:hover:before,
.outline-item-open>.outline-item>.outline-expander:before {
  	content: "\f0d7";
}

/** source code mode */
#typora-source {
	font-family: Courier, monospace;
    color: #6A6A6A;
}

.html-for-mac #typora-sidebar {
    -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
}

.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property,
.CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
	color: #428bca;
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
	color: #777777;
}

.typora-node .file-list-item-parent-loc, 
.typora-node .file-list-item-time, 
.typora-node .file-list-item-summary {
	font-family: arial, sans-serif;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: calc(1rem - 12px);
}

.md-mathjax-midline {
	background: #fafafa;
}

.md-fences .code-tooltip {
	bottom: -2em !important;
}

.dropdown-menu .divider {
	border-color: #e5e5e5;
}


</style><title>《深入理解Java虚拟机 JVM高级特性与最佳实践》相关查阅笔记</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='深入理解java虚拟机-jvm高级特性与最佳实践相关查阅笔记'><span>《深入理解Java虚拟机 JVM高级特性与最佳实践》相关查阅笔记</span></h1><h2 id='类字节码'><span>类字节码</span></h2><p><span>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</span></p><p><span>类字节码（Class Bytecode）是Java源代码编译后生成的一种中间表示形式，它是一组与特定Java类相关的指令集合。字节码被设计为一种与平台无关的形式，可以在任何支持Java虚拟机（JVM）的平台上执行。</span></p><p><span>Java源代码在编译过程中经过词法分析、语法分析、语义分析等步骤，最终生成字节码。字节码是一种由单字节（byte）指令组成的二进制数据流，每个指令都对应着一条Java虚拟机指令。</span></p><p><span>以下是一些常见的Java字节码指令示例：</span></p><ol start='' ><li><p><span>加载和存储指令：</span></p><ul><li><span>aload: 从局部变量表中加载引用类型变量到操作栈。</span></li><li><span>iload: 从局部变量表中加载int类型变量到操作栈。</span></li><li><span>astore: 将操作栈顶的引用类型数值存储到局部变量表中。</span></li><li><span>istore: 将操作栈顶的int类型数值存储到局部变量表中。</span></li></ul></li><li><p><span>运算指令：</span></p><ul><li><span>iadd: 将操作栈顶两个int类型数值相加。</span></li><li><span>imul: 将操作栈顶两个int类型数值相乘。</span></li><li><span>idiv: 将操作栈顶两个int类型数值相除。</span></li><li><span>irem: 将操作栈顶两个int类型数值取模（求余）。</span></li></ul></li><li><p><span>控制流指令：</span></p><ul><li><span>ifeq: 如果操作栈顶int类型数值等于0，则跳转到指定位置。</span></li><li><span>ifne: 如果操作栈顶int类型数值不等于0，则跳转到指定位置。</span></li><li><span>goto: 无条件跳转到指定位置。</span></li><li><span>return: 从当前方法返回。</span></li></ul></li></ol><p><span>Java字节码是一种中间表示形式，它可以在Java虚拟机中解释执行或即时编译成本地机器代码执行。字节码的优点是与平台无关，可以在不同的操作系统和硬件上执行相同的Java程序。同时，字节码也提供了丰富的指令集，支持各种操作，包括加载和存储数据、运算操作、控制流程等，实现了Java的核心功能和特性。</span></p><p><span>JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</span></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/java-jvm-class-1.png" referrerpolicy="no-referrer" alt="img"></p><p><span>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</span></p><p><span>Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。这里暂不详细的讲。</span></p><h3 id='class文件的结构属性'><span>Class文件的结构属性</span></h3><p><span>Java的class文件是一种二进制文件格式，用于存储已编译的Java类的信息。它包含了类的结构属性，描述了类的字段、方法、接口、访问修饰符等信息。下面是class文件的基本结构属性：</span></p><ol start='' ><li><p><span>魔数（Magic Number）：</span></p><ul><li><span>魔数是一个固定的4字节（32位）值，用于标识class文件的格式。</span></li><li><span>Java的魔数为0xCAFEBABE。</span></li></ul></li><li><p><span>版本信息（Version）：</span></p><ul><li><span>版本信息描述了class文件的Java版本和编译器版本。</span></li><li><span>包括主版本号和次版本号。</span></li></ul></li><li><p><span>常量池（Constant Pool）：</span></p><ul><li><span>常量池是class文件中的一个表结构，用于存储编译时生成的各种字面量和符号引用。</span></li><li><span>包括类名、字段名、方法名、接口名、字符串字面量、类和接口的符号引用等。</span></li></ul></li><li><p><span>访问标志（Access Flags）：</span></p><ul><li><span>访问标志指示了class文件中的类或接口的访问控制权限和特性。</span></li><li><span>包括public、final、abstract等修饰符。</span></li></ul></li><li><p><span>类信息（Class Information）：</span></p><ul><li><span>类信息包括类的全限定名、父类、接口等信息。</span></li></ul></li><li><p><span>字段表（Fields）：</span></p><ul><li><span>字段表描述了类中声明的所有字段的信息。</span></li><li><span>包括字段名、字段类型、字段修饰符等。</span></li></ul></li><li><p><span>方法表（Methods）：</span></p><ul><li><span>方法表描述了类中声明的所有方法的信息。</span></li><li><span>包括方法名、参数列表、返回类型、方法修饰符等。</span></li></ul></li><li><p><span>属性表（Attributes）：</span></p><ul><li><span>属性表用于存储附加的类、字段或方法的属性信息。</span></li><li><span>可以包括源文件名、行号表、注解等。</span></li></ul></li></ol><p><span>class文件的结构属性按照一定的规范和格式进行组织，这些属性共同构成了Java类的描述信息。Java虚拟机通过解析class文件，可以获取类的结构属性，实现类的加载、验证、准备和初始化等操作。以文本的形式打开生成的class文件，内容如下:</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="bash" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11.0703px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre>x</pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">cafe babe <span class="cm-number">0000</span> <span class="cm-number">0034</span> <span class="cm-number">0013</span> 0a00 <span class="cm-number">0400</span> 0f09</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0003</span> <span class="cm-number">0010</span> <span class="cm-number">0700</span> <span class="cm-number">1107</span> <span class="cm-number">0012</span> <span class="cm-number">0100</span> 016d <span class="cm-number">0100</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0149</span> <span class="cm-number">0100</span> 063c 696e <span class="cm-number">6974</span> 3e01 <span class="cm-number">0003</span> <span class="cm-number">2829</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">5601</span> <span class="cm-number">0004</span> 436f <span class="cm-number">6465</span> <span class="cm-number">0100</span> 0f4c 696e 654e</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">756d <span class="cm-number">6265</span> <span class="cm-number">7254</span> <span class="cm-number">6162</span> 6c65 <span class="cm-number">0100</span> <span class="cm-number">0369</span> 6e63</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0100</span> <span class="cm-number">0328</span> <span class="cm-number">2949</span> <span class="cm-number">0100</span> 0a53 6f75 <span class="cm-number">7263</span> <span class="cm-number">6546</span></span></pre><div class="" style="position: relative;"><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">696c <span class="cm-number">6501</span> <span class="cm-number">0009</span> 4d61 696e 2e6a <span class="cm-number">6176</span> 610c</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0007</span> <span class="cm-number">0008</span> 0c00 <span class="cm-number">0500</span> <span class="cm-number">0601</span> <span class="cm-number">0010</span> 636f 6d2f</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">7268</span> <span class="cm-number">7974</span> 686d 372f 4d61 696e <span class="cm-number">0100</span> 106a</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">6176</span> 612f 6c61 6e67 2f4f 626a <span class="cm-number">6563</span> <span class="cm-number">7400</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">2100</span> <span class="cm-number">0300</span> <span class="cm-number">0400</span> <span class="cm-number">0000</span> <span class="cm-number">0100</span> <span class="cm-number">0200</span> <span class="cm-number">0500</span> <span class="cm-number">0600</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0000</span> <span class="cm-number">0200</span> <span class="cm-number">0100</span> <span class="cm-number">0700</span> <span class="cm-number">0800</span> <span class="cm-number">0100</span> <span class="cm-number">0900</span> <span class="cm-number">0000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">1d00 <span class="cm-number">0100</span> <span class="cm-number">0100</span> <span class="cm-number">0000</span> 052a b700 01b1 <span class="cm-number">0000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0001</span> 000a <span class="cm-number">0000</span> <span class="cm-number">0006</span> <span class="cm-number">0001</span> <span class="cm-number">0000</span> <span class="cm-number">0003</span> <span class="cm-number">0001</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">000b 000c <span class="cm-number">0001</span> <span class="cm-number">0009</span> <span class="cm-number">0000</span> 001f <span class="cm-number">0002</span> <span class="cm-number">0001</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0000</span> <span class="cm-number">0007</span> 2ab4 <span class="cm-number">0002</span> <span class="cm-number">0460</span> ac00 <span class="cm-number">0000</span> <span class="cm-number">0100</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">0a00 <span class="cm-number">0000</span> <span class="cm-number">0600</span> <span class="cm-number">0100</span> <span class="cm-number">0000</span> <span class="cm-number">0800</span> <span class="cm-number">0100</span> 0d00</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-number">0000</span> <span class="cm-number">0200</span> 0e</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 471px;"></div><div class="CodeMirror-gutters" style="display: none; height: 471px;"></div></div></div></pre><ul><li><span>文件开头的4个字节(&quot;cafe babe&quot;)称之为 </span><code>魔数</code><span>，唯有以&quot;cafe babe&quot;开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</span></li><li><span>0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</span></li></ul><h3 id='反编译字节码文件'><span>反编译字节码文件</span></h3><p><span>反编译字节码文件是将已编译的Java类文件（.class文件）转换回Java源代码的过程。反编译可以帮助开发人员了解和分析已编译的代码，以及从中提取出原始的源代码逻辑。</span></p><p><span>有许多工具可以用于反编译字节码文件，其中比较流行的包括以下几种：</span></p><ol start='' ><li><span>JD-GUI：JD-GUI是一个免费的Java反编译工具，可以将.class文件转换为可读的Java源代码。它提供了用户友好的界面，可以浏览和导航反编译后的代码。</span></li><li><span>Fernflower：Fernflower是一个开源的Java反编译器，能够将.class文件转换为Java源代码。它具有高度的稳定性和准确性，并且能够处理复杂的字节码结构。</span></li><li><span>Procyon：Procyon是另一个开源的Java反编译器，能够将.class文件反编译为易读的Java源代码。它提供了高质量的反编译输出，并支持Java 8的新特性。</span></li><li><span>CFR：CFR是一个开源的Java反编译工具，可以将.class文件反编译为Java源代码。它具有良好的代码重构能力，能够还原出原始的代码结构和逻辑。</span></li></ol><p><span>这些工具可以将.class文件转换为Java源代码，但由于编译过程中的信息丢失以及优化等因素，反编译后的源代码可能不完全与原始源代码相同。一些变量名、注释和代码格式可能会有所不同，但通常仍能提供有用的参考和理解。</span></p><p><span>需要注意的是，反编译字节码文件应遵守相关的法律和规定，确保只在合法和授权的情况下进行使用。</span></p><h3 id='常量池'><span>常量池</span></h3><p><span>常量池（Constant Pool）是Java字节码文件中的一个重要部分，它是一个表结构，用于存储编译时生成的各种字面量和符号引用。常量池包含了类、接口、字段、方法的相关信息，并且提供了运行时解析这些符号引用的能力。</span></p><p><span>以下是常量池中可能包含的一些常见的常量类型：</span></p><ol start='' ><li><span>字符串常量（String Constants）：常量池中存储了字符串字面量的值，以及对应的索引。在Java源代码中的字符串常量，如&quot;Hello, World!&quot;，在常量池中会存储其值。</span></li><li><span>类和接口的符号引用（Class and Interface Symbol References）：常量池中存储了类和接口的符号引用，包括类的全限定名、父类、接口等信息。这些符号引用在运行时会被解析为实际的类和接口。</span></li><li><span>字段符号引用（Field Symbol References）：常量池中存储了字段的符号引用，包括字段所属类的全限定名、字段名称和字段类型等信息。这些符号引用在运行时会被解析为实际的字段。</span></li><li><span>方法符号引用（Method Symbol References）：常量池中存储了方法的符号引用，包括方法所属类的全限定名、方法名称、参数类型和返回类型等信息。这些符号引用在运行时会被解析为实际的方法。</span></li><li><span>字面量（Literals）：常量池中还存储了一些字面量的值，如整数、浮点数、长整数、双精度浮点数等。</span></li></ol><p><span>常量池的设计旨在提供一种中间表示形式，使得Java字节码可以在不同的平台上执行。Java虚拟机在加载类的过程中会解析常量池中的符号引用，并进行符号解析和链接操作，将符号引用转换为具体的内存地址或方法指针，以实现类的加载和初始化。常量池的使用对于Java虚拟机的执行和类的运行具有重要的意义。</span></p><h3 id='方法表集合'><span>方法表集合</span></h3><p><span>在Java字节码文件中，方法表集合（Methods Table）是一部分常量池中的信息，用于描述一个类中声明的所有方法的相关属性和行为。方法表集合存储了方法的名称、参数列表、返回类型、访问修饰符、异常处理信息等。</span></p><p><span>方法表集合是由多个方法表项（Method Table Entry）组成的。每个方法表项对应一个类中的方法，并包含了方法的各种属性。以下是方法表项可能包含的信息：</span></p><ol start='' ><li><span>方法名称（Method Name）：方法的名称，用于唯一标识一个方法。</span></li><li><span>方法描述符（Method Descriptor）：方法的参数列表和返回类型的描述符，用于指定方法的参数类型和返回类型。例如，方法描述符</span><code>(Ljava/lang/String;)V</code><span>表示一个接受一个String类型参数且返回类型为void的方法。</span></li><li><span>访问修饰符（Access Flags）：访问修饰符用于控制方法的访问权限和特性，例如public、private、static等。</span></li><li><span>参数列表（Parameter List）：方法的参数列表，包括参数的数量、类型和顺序。</span></li><li><span>返回类型（Return Type）：方法的返回类型，指定方法执行完后返回的数据类型。</span></li><li><span>异常处理表（Exception Handler Table）：如果方法中存在异常处理块，异常处理表会记录异常类型和相应的处理逻辑。</span></li><li><span>属性表（Attributes）：方法的附加属性信息，如方法的字节码指令、局部变量表、异常表等。</span></li></ol><p><span>方法表集合中的方法项按照顺序排列，可以通过索引来访问和操作特定的方法。Java虚拟机在加载类的过程中会解析方法表集合，以执行方法的调用和执行。方法表集合提供了对类中方法的详细描述，使得Java虚拟机可以准确地定位和执行方法的字节码指令。</span></p><h2 id='字节码增强技术'><span>字节码增强技术</span></h2><p><span>字节码增强技术是指在Java字节码级别对程序进行修改和增强的技术。它可以在不修改源代码的情况下，对现有的Java类进行功能扩展、性能优化、调试支持等操作。以下是几种常见的字节码增强技术：</span></p><ol start='' ><li><span>字节码插桩（Bytecode Instrumentation）：字节码插桩是在字节码中插入额外的代码，用于记录方法的调用、参数传递、异常处理等信息。它常用于性能分析、代码覆盖率统计、动态跟踪和调试等领域。</span></li><li><span>动态代理（Dynamic Proxy）：动态代理是利用字节码技术在运行时动态生成代理类的过程。通过在方法调用前后插入额外的逻辑，动态代理可以实现方法级别的拦截和增强。它常用于实现AOP（面向切面编程）的横切逻辑。</span></li><li><span>字节码修改工具（Bytecode Modification Tools）：字节码修改工具可以直接对字节码进行修改，包括插入、删除、替换字节码指令等操作。常用的字节码修改工具包括ASM、ByteBuddy和Javassist等，它们提供了丰富的API和功能，可以灵活地修改字节码。</span></li><li><span>字节码增强框架（Bytecode Enhancement Frameworks）：字节码增强框架是一组工具和库，用于简化字节码增强的开发过程。这些框架提供了高级的API和插件机制，使得开发人员可以通过配置和扩展来实现对字节码的增强。常见的字节码增强框架包括AspectJ、Spring AOP和Byte Buddy等。</span></li></ol><p><span>字节码增强技术可以应用于许多领域，包括性能优化、安全增强、代码生成、动态配置等。它在一定程度上提高了Java程序的灵活性和可扩展性，允许开发人员以更加细粒度的方式对代码进行修改和控制。然而，使用字节码增强技术需要谨慎操作，遵守相关规范，并确保对程序行为和性能的影响进行充分测试和评估。</span></p><h2 id='java虚拟机运行时内存区域'><span>Java虚拟机运行时内存区域</span></h2><p><span>Java虚拟机在运行时将内存划分为不同的区域，每个区域都有特定的作用和生命周期。这些内存区域包括以下几个方面：</span></p><ol start='' ><li><span>程序计数器（Program Counter Register）：</span>
<span>程序计数器是一块较小的内存区域，它是每个线程私有的。它用于指示当前线程正在执行的字节码指令的地址或索引。在线程切换时，程序计数器保存了线程执行的位置，以便线程恢复执行时能够继续执行。</span></li><li><span>Java虚拟机栈（Java Virtual Machine Stacks）：</span>
<span>Java虚拟机栈也是线程私有的，用于存储方法的局部变量、操作数栈、方法返回值和方法调用的信息。每个方法在执行时都会创建一个栈帧，栈帧用于存储方法的局部变量和中间结果。栈帧按照方法调用的顺序进行压栈和出栈操作。</span></li><li><span>本地方法栈（Native Method Stack）：</span>
<span>本地方法栈与Java虚拟机栈类似，用于存储调用本地方法（Native Method）的信息和数据。本地方法是使用本地语言（如C或C++）编写的方法，它们不是Java字节码，而是直接调用底层操作系统或硬件的代码。</span></li><li><span>Java堆（Java Heap）：</span>
<span>Java堆是Java虚拟机管理的最大的一块内存区域，被所有线程共享。它用于存储对象实例和数组。Java堆是垃圾收集器管理的主要区域，用于分配和回收内存。Java堆可以根据需要进行动态扩展或收缩。</span></li><li><span>方法区（Method Area）：</span>
<span>方法区也被称为永久代（Permanent Generation），它用于存储类的结构信息、运行时常量池、静态变量、即时编译器编译后的代码等数据。方法区是所有线程共享的，它在Java虚拟机启动时被创建，并且在虚拟机退出时销毁。</span></li><li><span>运行时常量池（Runtime Constant Pool）：</span>
<span>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。运行时常量池是每个类或接口的常量池表的运行时表示形式。</span></li></ol><p><span>除了上述内存区域，Java虚拟机还可能包含一些其他的内存区域，如直接内存（Direct Memory）用于NIO操作、元空间（Metaspace）用于存储类的元数据等。这些内存区域的存在和具体实现可能因不同的Java虚拟机而不同。</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="sql" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11.0703px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">+--------------------------------------------------+</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Java虚拟机内存 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">+--------------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  线程共享区域 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  方法区（Method Area） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 堆 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  静态变量与类信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  数组与对象实例 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  线程私有区域 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 程序计数器（Program Counter） &nbsp; &nbsp; &nbsp; <span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Java虚拟机栈（Java <span class="cm-keyword">Virtual</span> Stack） &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp;  本地方法栈（Native Method Stack） &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  直接内存 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">|</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 堆外内存 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-operator">|</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">|</span> &nbsp; &nbsp;<span class="cm-operator">+-------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-operator">+--------------------------------------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 758px;"></div><div class="CodeMirror-gutters" style="display: none; height: 758px;"></div></div></div></pre><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/image-20230630201023859.png" referrerpolicy="no-referrer" alt="image-20230630201023859"></p><h3 id='程序计数器'><span>程序计数器</span></h3><h3 id='java虚拟机栈'><span>Java虚拟机栈</span></h3><p><span>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</span></p><p><span>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</span></p><p><span>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</span></p><p><span>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</span></p><h3 id='本地方法栈'><span>本地方法栈</span></h3><p><span>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</span></p><h3 id='java堆'><span>Java堆</span></h3><p><span>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配“</span></p><p><span>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词。</span></p><p><span>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区</span>
<span>（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</span></p><p><span>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。</span></p><h3 id='方法区'><span>方法区</span></h3><p><span>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。</span></p><h3 id='运行时常量池'><span>运行时常量池</span></h3><p><span>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</span></p><p><span>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。</span></p><h3 id='直接内存'><span>直接内存</span></h3><p><span>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存。</span></p><h2 id='hotspot虚拟机对象'><span>HotSpot虚拟机对象</span></h2><h3 id='对象的创建'><span>对象的创建</span></h3><p><span>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</span></p><p><span>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</span></p><p><span>在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</span></p><p><span>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</span></p><p><span>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</span></p><p><span>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的</span><init><span>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行</span><init><span> ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</span></p><h3 id='对象的内存布局'><span>对象的内存布局</span></h3><h2 id='垃圾收集器与内存分配策略'><span>垃圾收集器与内存分配策略</span></h2><p><span>前面介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性。</span></p><p><span>而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。</span></p><h3 id='如何判断对象已死'><span>如何判断对象已死？</span></h3><h4 id='引用计数法'><span>引用计数法</span></h4><p><span>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，</span><strong><span>譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</span></strong></p><h4 id='可达性分析算法'><span>可达性分析算法</span></h4><p><span>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</span></p><p><span>如图3-1所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</span></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/image-20230630204022739.png" referrerpolicy="no-referrer" alt="image-20230630204022739"></p><p><span>                                                               图3-1　利用可达性分析算法判定对象是否可回收</span></p><p><strong><span>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</span></strong></p><p><span>·</span><span>	</span><span>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</span></p><p><span>·</span><span>	</span><span>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</span>
<span>·</span><span>	</span><span>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</span></p><p><span>·</span><span>	</span><span>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</span>
<span>·</span><span>	</span><span>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</span></p><p><span>·</span><span>	</span><span>所有被同步锁（synchronized关键字）持有的对象。</span>
<span>·</span><span>	</span><span>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</span></p><h4 id='再谈引用'><span>再谈引用</span></h4><p><span>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。</span></p><p><span>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</span></p><p><strong><span>强引用</span></strong><span>是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</span></p><p><strong><span>软引用</span></strong><span>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</span></p><p><strong><span>弱引用</span></strong><span>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</span></p><p><strong><span>虚引用</span></strong><span>也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</span></p><h3 id='垃圾收集算法'><span>垃圾收集算法</span></h3><p><span>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。由于引用计数式垃圾收集算法在主流Java虚拟机中均未涉及，所以我们暂不了解它。</span></p><p><span>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</span></p><p><span>1）</span><span>	</span><span>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</span>
<span>2）</span><span>	</span><span>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</span></p><p><span>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</span></p><p><span>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分。</span></p><p><span>把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代</span>
<span>（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</span></p><p><strong><span>一些概念：</span></strong></p><p><span>■</span><span>	</span><span>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</span></p><p><span>■</span><span>	</span><span>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</span></p><p><span>■</span><span>	</span><span>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</span></p><p><span>■</span><span>	</span><span>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</span></p><h4 id='常见垃圾收集算法'><span>常见垃圾收集算法</span></h4><p><strong><span>常见的垃圾收集算法包括：</span></strong></p><ol start='' ><li><span>标记-清除算法（Mark and Sweep）：标记-清除算法通过标记阶段标记存活对象，然后在清除阶段回收未标记的对象，并释放其占用的内存空间。然而，该算法存在内存碎片问题和效率问题。</span></li><li><span>标记-整理算法（Mark and Compact）：标记-整理算法在标记阶段标记存活对象，然后在整理阶段将存活对象向一端移动，使其在内存中连续排列，最后释放整个堆的未使用空间。该算法解决了标记-清除算法的内存碎片问题。</span></li><li><span>标记-复制算法（Mark and Copy）：标记-复制算法将堆内存分为两个相等大小的区域，一半用于存放存活对象，另一半作为空闲区域。在标记阶段标记存活对象后，在复制阶段将存活对象从一个区域复制到另一个区域，并按照内存地址顺序进行紧凑排列。最后，释放原有的堆内存，成为新的空闲内存。该算法解决了内存碎片问题。</span></li><li><span>分代算法（Generational）：分代算法根据对象的生命周期将堆内存划分为多个代（Generation），通常是年轻代（Young Generation）和老年代（Old Generation）。年轻代中的对象生命周期较短，老年代中的对象生命周期较长。根据不同代的特点，可以采用不同的垃圾收集算法和策略，例如在年轻代使用复制算法，在老年代使用标记-整理算法。</span></li><li><span>增量收集算法（Incremental）：增量收集算法将垃圾回收过程划分为多个小步骤，在应用程序执行的间隙逐步完成垃圾回收。通过将垃圾收集过程分散到多个时间片段，减少了每次回收时的停顿时间，提高了应用程序的响应性能。</span></li><li><span>并发收集算法（Concurrent）：并发收集算法允许垃圾回收与应用程序的执行同时进行，减少了垃圾回收对应用程序的影响。通过与应用程序并发执行，可以在较短的停顿时间内完成垃圾收集。</span></li></ol><p><span>这些垃圾收集算法可以单独使用或组合使用，以达到更高的垃圾回收效率和性能。不同的垃圾收集器和虚拟机实现可能选择不同的算法和策略</span></p><h4 id='标记-清除算法'><span>标记-清除算法</span></h4><p><span>标记-清除算法（Mark and Sweep）是一种常见的垃圾收集算法，用于回收无用的对象，并释放它们所占用的内存空间。该算法主要包括两个阶段：标记阶段和清除阶段。</span></p><p><span>下面是标记-清除算法的基本流程：</span></p><ol start='' ><li><p><span>标记阶段（Mark）：</span></p><ul><li><span>从根对象开始，遍历可访问的对象图（对象之间的引用关系），将所有可达的对象标记为存活状态。</span></li><li><span>常见的根对象包括堆栈中的局部变量、静态变量和常量等。</span></li></ul></li><li><p><span>清除阶段（Sweep）：</span></p><ul><li><span>遍历整个堆内存，将未被标记的对象判定为垃圾对象。</span></li><li><span>回收垃圾对象占用的内存，并将这些内存空间标记为可用。</span></li></ul></li></ol><p><span>标记-清除算法的优点是能够正确地标记和清除无用的对象，确保不会回收仍然被引用的对象。然而，该算法也存在一些问题：</span></p><ol start='' ><li><span>内存碎片问题：清除阶段会产生大量不连续的内存碎片，导致分配大对象时无法找到连续的内存空间。</span></li><li><span>垃圾收集效率问题：标记-清除算法需要遍历整个堆内存，包括存活对象和垃圾对象，效率较低。</span></li><li><span>暂停问题：在垃圾回收过程中，需要停止应用程序的执行，可能导致较长的停顿时间，影响应用的响应性能。</span></li></ol><p><span>为了解决标记-清除算法的问题，现代的垃圾收集器通常采用了更高效的算法，如复制算法、标记-整理算法和分代算法等。这些算法结合了不同的策略和技术，以提高垃圾收集的效率和内存利用率，减少暂停时间，并解决内存碎片问题。</span></p><p><span>标记-清除算法的执行过程如图3-2所示。</span></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/image-20230630210049468.png" referrerpolicy="no-referrer" alt="image-20230630210049468"></p><p><span>                                                                                图3-2　“标记-清除”算法示意图</span></p><h4 id='标记-复制算法'><span>标记-复制算法</span></h4><p><span>标记-复制算法（Mark and Copy）是一种常见的垃圾收集算法，用于回收无用的对象并解决内存碎片问题。该算法将堆内存分为两个相等大小的区域，一半称为&quot;From&quot;区域，另一半称为&quot;To&quot;区域。</span></p><p><span>下面是标记-复制算法的基本流程：</span></p><ol start='' ><li><p><span>标记阶段（Mark）：</span></p><ul><li><span>从根对象开始，遍历可访问的对象图，将所有可达的对象标记为存活状态。</span></li></ul></li><li><p><span>复制阶段（Copy）：</span></p><ul><li><span>将所有存活对象从&quot;From&quot;区域复制到&quot;To&quot;区域，并按照内存地址的顺序进行紧凑排列。</span></li><li><span>同时，更新引用关系，使得引用指向复制后的对象。</span></li></ul></li><li><p><span>交换区域：</span></p><ul><li><span>将&quot;From&quot;区域和&quot;To&quot;区域互换，此时原来的&quot;From&quot;区域变为新的空闲区域。</span></li></ul></li><li><p><span>更新引用关系：</span></p><ul><li><span>遍历所有存活对象，更新引用指向的新位置。</span></li></ul></li><li><p><span>释放原有堆内存：</span></p><ul><li><span>释放之前的&quot;From&quot;区域，成为新的空闲内存，以便供后续对象的分配使用。</span></li></ul></li></ol><p><span>通过标记-复制算法，垃圾收集器能够解决内存碎片问题，因为存活对象在复制过程中被紧凑排列，不会产生碎片。然而，标记-复制算法也存在一些问题：</span></p><ol start='' ><li><span>空间开销问题：</span><strong><span>标记-复制算法需要两倍于实际存活对象大小的内存空间，因为需要同时维护&quot;From&quot;区域和&quot;To&quot;区域。</span></strong></li><li><span>效率问题：</span><strong><span>由于需要复制存活对象，标记-复制算法在垃圾回收时可能会有较高的复制开销。</span></strong></li></ol><p><span>为了解决标记-复制算法的空间开销和效率问题，现代的垃圾收集器通常采用了更复杂的算法和策略，如分代算法、增量收集算法、压缩算法等。这些算法结合了不同的技术，以提高垃圾收集的效率和内存利用率，并在不同场景下进行优化。</span></p><p><span>标记-复制算法的执行过程如图3-3所示。</span></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/image-20230630210755787.png" referrerpolicy="no-referrer" alt="image-20230630210755787"></p><p><span>                                                                                  图3-3　标记-复制算法示意图</span></p><h4 id='标记-整理算法'><span>标记-整理算法</span></h4><p><span>标记-整理算法（Mark and Compact）是一种垃圾收集算法，用于回收无用的对象并整理内存空间。与标记-清除算法不同，标记-整理算法通过在回收阶段将存活对象移动到一端，并清理整个堆内存的未使用空间来解决内存碎片问题。</span></p><p><span>下面是标记-整理算法的基本流程：</span></p><ol start='' ><li><p><span>标记阶段（Mark）：</span></p><ul><li><span>从根对象开始，遍历可访问的对象图，将所有可达的对象标记为存活状态。</span></li></ul></li><li><p><span>整理阶段（Compact）：</span></p><ul><li><span>将存活对象向一端移动，使它们在内存中连续排列。</span></li><li><span>同时，记录存活对象的新位置，以便更新引用关系。</span></li></ul></li><li><p><span>更新引用关系：</span></p><ul><li><span>遍历所有存活对象，更新引用指向的新位置。</span></li></ul></li><li><p><span>释放未使用空间：</span></p><ul><li><span>根据整理阶段的结果，释放整个堆内存的未使用空间，使其可供后续的对象分配使用。</span></li></ul></li></ol><p><span>标记-整理算法的优点是能够解决标记-清除算法产生的内存碎片问题，使得分配大对象时更容易找到连续的内存空间。然而，标记-整理算法也存在一些问题：</span></p><ol start='' ><li><span>效率问题：与标记-清除算法相比，标记-整理算法需要进行额外的整理步骤，可能导致较高的垃圾回收开销。</span></li><li><span>暂停问题：在整理阶段，需要停止应用程序的执行，可能导致较长的停顿时间，影响应用的响应性能。</span></li></ol><p><span>为了解决标记-整理算法的效率和暂停问题，现代的垃圾收集器通常采用了更复杂的算法和技术，如分代算法、增量收集算法、并发收集算法等。这些算法结合了多种策略和技术，以提高垃圾收集的效率和响应性能，并满足不同场景下的需求。“标记-整理”算法的示意图如图3-4所示。</span></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/image-20230630210822138.png" referrerpolicy="no-referrer" alt="image-20230630210822138"></p><p><span>                                                                                  图3-4　“标记-整理”算法示意图</span></p><h4 id='分代垃圾收集算法'><span>分代垃圾收集算法</span></h4><p><span>分代垃圾收集算法（Generational Garbage Collection）是一种常见的垃圾收集策略，根据对象的生命周期将堆内存划分为多个代（Generation），通常是年轻代（Young Generation）、中年代（Mid Generation）和老年代（Old Generation）。</span></p><p><span>分代垃圾收集算法的基本思想是根据对象的特征和存活特性来设置不同的收集策略，以提高垃圾回收的效率。一般来说，年轻代中的对象生命周期较短，老年代中的对象生命周期较长。根据这个特性，分代垃圾收集器将垃圾收集任务集中在年轻代上，而对老年代的垃圾收集相对较少进行。</span></p><p><strong><span>下面是分代垃圾收集算法的基本流程：</span></strong></p><ol start='' ><li><p><span>年轻代（Young Generation）：</span></p><ul><li><span>年轻代通常由一个Eden区和两个Survivor区（通常称为S0和S1）组成。</span></li><li><span>初始时，新创建的对象被分配到Eden区。</span></li><li><span>当Eden区满时，进行一次Minor GC（年轻代垃圾收集），将存活的对象复制到一个Survivor区，同时清空Eden区。</span></li><li><span>在下一次Minor GC时，将从上一次GC中幸存的对象复制到另一个Survivor区，同时清空该Survivor区和Eden区。</span></li><li><span>对象经过多次复制仍然存活的，将被晋升到老年代。</span></li></ul></li><li><p><span>老年代（Old Generation）：</span></p><ul><li><span>老年代中存放生命周期较长的对象，一般由年轻代晋升而来。</span></li><li><span>对老年代进行垃圾收集时，通常使用更耗时但更全面的垃圾收集算法，如标记-整理算法或标记-清除算法。</span></li></ul></li></ol><p><span>分代垃圾收集算法的优点是根据对象的生命周期进行针对性的垃圾收集，提高了垃圾回收的效率。因为大部分对象的生命周期较短，所以在年轻代的Minor GC可以更频繁地进行，减少了整个堆的垃圾回收时间。同时，老年代中的对象较少进行垃圾回收，减少了全堆垃圾回收的频率和开销。</span></p><p><strong><span>常见的分代垃圾收集器包括Serial收集器、Parallel收集器、CMS收集器和G1收集器等，它们根据具体的垃圾回收策略和算法来进行分代垃圾收集。</span></strong></p><h4 id='增量收集算法'><span>增量收集算法</span></h4><h4 id='并发收集算法'><span>并发收集算法</span></h4><h4 id='常见的垃圾收集器'><span>常见的垃圾收集器</span></h4><p><span>常见的垃圾收集器有以下几种：</span></p><ol start='' ><li><span>Serial收集器（Serial Garbage Collector）：Serial收集器是一种单线程的垃圾收集器，使用标记-复制算法。它在进行垃圾收集时会暂停应用程序的执行，并逐个扫描堆中的对象进行标记和复制。Serial收集器适用于单核CPU或小内存环境。</span></li><li><span>Parallel收集器（Parallel Garbage Collector）：Parallel收集器是一种多线程的垃圾收集器，使用标记-复制算法或标记-整理算法。它能够并行地进行垃圾收集，提高垃圾回收的效率。Parallel收集器适用于多核CPU的环境。</span></li><li><span>CMS收集器（Concurrent Mark Sweep Garbage Collector）：CMS收集器是一种并发的垃圾收集器，使用标记-清除算法。它可以在应用程序执行的同时进行垃圾收集，减少垃圾回收对应用程序的影响。CMS收集器适用于对停顿时间有严格要求的应用程序。</span></li><li><span>G1收集器（Garbage First Garbage Collector）：G1收集器是一种面向服务端应用的垃圾收集器，使用标记-整理算法。它将堆内存划分为多个大小相等的区域，通过并行和并发的方式进行垃圾回收，优化了大堆内存的垃圾收集性能和停顿时间。</span></li><li><span>ZGC收集器（Z Garbage Collector）：ZGC收集器是一种低延迟的垃圾收集器，使用标记-整理算法。它通过并发的方式进行垃圾收集，减少了垃圾回收对应用程序的停顿时间，并提供了非常短的垃圾收集停顿时间。</span></li></ol><p><span>除了上述垃圾收集器，还有一些特定场景下的垃圾收集器，如Serial Old收集器、Parallel Old收集器、Epsilon收集器等，它们针对特定的应用场景和性能需求进行了优化。</span></p><p><span>需要注意的是，不同的垃圾收集器适用于不同的应用场景和硬件环境，选择合适的垃圾收集器需要考虑应用程序的性能要求、内存大小、处理器数量等因素。</span><strong></strong></p><h2 id='java类加载机制'><span>Java类加载机制</span></h2><h2 id='1类的生命周期'><span>1、类的生命周期</span></h2><p><span>其中类加载的过程包括了</span><code>加载</code><span>、</span><code>验证</code><span>、</span><code>准备</code><span>、</span><code>解析</code><span>、</span><code>初始化</code><span>五个阶段。在这五个阶段中，</span><code>加载</code><span>、</span><code>验证</code><span>、</span><code>准备</code><span>和</span><code>初始化</code><span>这四个阶段发生的顺序是确定的，</span><em><span>而</span><code>解析</code><span>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)</span></em><span>。</span><strong><span>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</span></strong></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/java_jvm_classload_2.png" referrerpolicy="no-referrer" alt="img"></p><h3 id='类的加载-查找并加载类的二进制数据'><span>类的加载: 查找并加载类的二进制数据</span></h3><p><span>加载是类加载过程的第一个阶段，</span><strong><span>在加载阶段，虚拟机需要完成以下三件事情:</span></strong></p><p><span>1、通过一个类的全限定名来获取其定义的二进制字节流。</span></p><p><span>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span></p><p><span>3、</span><strong><span>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</span></strong></p><p><img src="%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%9B%B8%E5%85%B3%E6%9F%A5%E9%98%85%E7%AC%94%E8%AE%B0.assets/java_jvm_classload_1.png" referrerpolicy="no-referrer" alt="img"></p><p><span>相对于类加载的其他阶段而言，</span><em><span>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</span></em><span>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</span></p><p><span>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个</span><code>java.lang.Class</code><span>类的对象，这样便可以通过该对象访问方法区中的这些数据。</span></p><p><span>类加载器并不需要等到某个类被“首次主动使用”时再加载它，</span><strong><span>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</span></strong></p><h3 id='类加载过程中的解析'><strong><span>类加载过程中的解析</span></strong></h3><p><span>在Java虚拟机的类加载过程中，解析（Resolution）是其中一个重要的步骤。解析阶段的主要目的是将类、方法、字段等符号引用转化为直接引用，以便在运行时能够快速访问目标。</span></p><p><span>解析的过程可以进一步细分为以下几个步骤：</span></p><ol start='' ><li><p><span>类或接口的解析：</span></p><ul><li><span>类或接口的全限定名被解析为一个直接引用，即指向类或接口在方法区中的存储结构的指针。</span></li><li><span>解析过程会检查类或接口是否存在、是否已被加载和链接。</span></li></ul></li><li><p><span>字段解析：</span></p><ul><li><span>字段的解析是将字段符号引用解析为对应字段在内存中的直接引用，包括字段所在的类和字段的偏移量。</span></li><li><span>解析过程会验证字段是否存在、是否可访问等。</span></li></ul></li><li><p><span>方法解析：</span></p><ul><li><span>方法的解析是将方法符号引用解析为对应方法在内存中的直接引用，包括方法所在的类和方法的入口地址。</span></li><li><span>解析过程会验证方法是否存在、是否可访问等。</span></li></ul></li></ol><p><span>解析阶段的主要工作是通过</span><strong><span>符号引用</span></strong><span>在运行时将其转化为</span><strong><span>直接引用</span></strong><span>，以便在程序中实际调用和访问类、方法和字段。这样可以提高程序的执行效率，并在解析过程中进行必要的验证和安全检查。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机示例上翻译出来的直接引用一般不会相同。</span></p><p><span>需要注意的是，解析阶段是在类加载的准备阶段之后进行的，准备阶段主要是为静态字段分配内存并设置默认初始值。解析阶段则进一步完善了符号引用与直接引用之间的对应关系。</span></p><h3 id='类与类加载器'><strong><span>类与类加载器</span></strong></h3><p><span>在Java中，每个类都与一个特定的类加载器相关联。类加载器负责加载类的二进制数据，并生成对应的Class对象。类与类加载器之间的关系是一对一的。</span></p><p><span>当一个类需要被使用时，Java虚拟机通过类加载器来加载它。类加载器根据类的全限定名，从特定的位置（如文件系统、网络等）获取类的字节码，并将其转换为内存中的类定义对象。这个类定义对象就是Class对象。</span></p><p><span>类加载器之间的关系通常是层次结构的，采用双亲委派模型。在双亲委派模型中，有多个类加载器按照一定的层次结构进行工作，每个类加载器都有一个父类加载器（除了根加载器）。当一个类加载器需要加载类时，它首先会委派给父类加载器来尝试加载。只有当父类加载器无法加载时，子类加载器才会尝试加载。</span></p><p><span>这种类与类加载器之间的关系有以下特点：</span></p><ol start='' ><li><span>命名空间隔离：不同类加载器具有不同的命名空间，同一个类在不同的类加载器加载下是不同的类。这样可以实现类的隔离，不同类加载器加载的类互相不可见。</span></li><li><span>可见性：子类加载器可以访问父类加载器加载的类，但父类加载器无法访问子类加载器加载的类。这样可以确保核心类库的安全性。</span></li><li><span>类的重复加载：通过双亲委派模型，类加载器可以避免重复加载同一个类。如果一个类已经被父类加载器加载过，子类加载器就不会再次加载，直接使用父类加载器加载的类。</span></li></ol><p><span>通过这种类与类加载器之间的关系，Java实现了一种动态的类加载机制，可以在运行时动态加载和卸载类，实现了Java平台的动态性和灵活性。同时，它也为Java提供了插件化和模块化的支持。</span></p><h3 id='类加载器'><strong><span>类加载器</span></strong></h3><p><span>类加载器（ClassLoader）是Java虚拟机（JVM）的一个重要组件，负责将类的二进制数据加载到内存，并生成对应的Class对象。类加载器是实现Java平台的重要机制之一，它具有以下特点：</span></p><ol start='' ><li><p><span>分层加载：类加载器采用了分层加载的机制，即将类加载的请求委派给父类加载器。这种双亲委派模型可以避免类的重复加载，确保类的一致性和安全性。</span></p></li><li><p><font color='orange'><span>双亲委派模型</span></font><span>：类加载器按照一定的层次关系进行工作，首先检查父类加载器是否可以完成加载任务，只有在父类加载器无法加载时，才由子类加载器尝试加载。这样可以确保核心类库的安全和一致性，并避免恶意代码的加载。</span></p></li><li><p><font color='orange'><span>类加载器的层次结构</span></font><span>：类加载器形成了一个层次结构，根据类加载器的父子关系可以分为以下几个层次：</span></p><ul><li><span>根加载器（Bootstrap Class Loader）：它是虚拟机的一部分，用于加载Java核心类库，通常由C++编写，无法在Java代码中直接获取。</span></li><li><span>扩展加载器（Extension Class Loader）：负责加载Java的扩展类库，位于</span><code>jre/lib/ext</code><span>目录下的JAR包。</span></li><li><span>应用程序加载器（Application Class Loader）：也称为系统类加载器，负责加载应用程序的类，是用户自定义的类加载器的默认父加载器。</span></li><li><span>自定义类加载器：用户可以根据需要自定义类加载器，继承自ClassLoader类，实现自己的类加载逻辑。</span></li></ul></li><li><p><font color='orange'><span>类加载器的特性</span></font><span>：类加载器具有以下特性：</span></p><ul><li><span>可见性：子类加载器可以访问父类加载器加载的类，但父类加载器无法访问子类加载器加载的类。</span></li><li><span>委派机制：类加载器在加载类时会委派给父类加载器，只有在父类加载器无法加载时才会尝试自己加载。</span></li><li><span>命名空间：每个类加载器都有自己的命名空间，同一命名空间内的类是相互可见的，不同命名空间内的类是相互隔离的。</span></li></ul></li></ol><p><span>自定义类加载器可以实现各种加载策略，如从网络加载类、从非标准的文件系统加载类等。类加载器的灵活性使得Java平台具备了很强的动态性和可扩展性。</span></p><p><span>启动类加载器（Bootstrap Class Loader）是Java虚拟机中的最顶层类加载器，它负责加载Java核心类库，如</span><code>rt.jar</code><span>中的类。启动类加载器是虚拟机的一部分，通常由C++实现，无法在Java代码中直接获取。它是所有其他类加载器的父加载器。</span></p><p><span>扩展类加载器（Extension Class Loader）是Java虚拟机的扩展机制的一部分，它用于加载Java的扩展类库。扩展类加载器位于</span><code>jre/lib/ext</code><span>目录下，它加载的类库不仅包括JDK的标准扩展类库，还可以包含用户自定义的扩展类库。扩展类加载器是由Java编写的，是应用程序类加载器的父加载器。</span></p><p><span>应用程序类加载器（Application Class Loader）也称为系统类加载器，是Java虚拟机中最常用的类加载器。它负责加载应用程序的类，即应用程序的classpath下的类。应用程序类加载器是由Java编写的，是自定义类加载器的默认父加载器。</span></p><p><span>启动类加载器、扩展类加载器和应用程序类加载器之间构成了类加载器的层次结构，如下所示：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="lua" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="lua"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11.0703px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">------------------+</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | <span class="cm-variable">Bootstrap</span> <span class="cm-variable">Class</span>  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | &nbsp; &nbsp;<span class="cm-variable">Loader</span> &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +<span class="cm-comment">--------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <span class="cm-variable">Extension</span> &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | <span class="cm-variable">Class</span> <span class="cm-variable">Loader</span> |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +<span class="cm-comment">--------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">---------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | <span class="cm-variable">Application</span> &nbsp; &nbsp; &nbsp; &nbsp; |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | <span class="cm-variable">Class</span> <span class="cm-variable">Loader</span> &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">---------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">---------------------+</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">User</span> &nbsp; &nbsp; &nbsp; &nbsp; |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  | <span class="cm-variable">Class</span> <span class="cm-variable">Loader</span> &nbsp; &nbsp; &nbsp;  |</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +<span class="cm-comment">---------------------+</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 575px;"></div><div class="CodeMirror-gutters" style="display: none; height: 575px;"></div></div></div></pre><p><span>类加载器之间的关系是父子关系，即启动类加载器是扩展类加载器的父加载器，扩展类加载器是应用程序类加载器的父加载器。这种层次结构和父子关系的设计使得类加载器可以按照一定的顺序委派加载类，确保类的一致性和安全性。同时，类加载器的层次结构也为动态加载和模块化提供了支持。</span></p><h3 id='启动类加载器'><span>启动类加载器</span></h3><p><span>启动类加载器（Bootstrap Class Loader）是Java虚拟机中最顶层的类加载器，它是虚拟机的一部分，并不是由Java编写的，通常由C++实现。启动类加载器负责加载Java核心类库，如</span><code>java.lang</code><span>、</span><code>java.util</code><span>等，这些类库是Java虚拟机运行时的一部分。</span></p><p><span>启动类加载器是所有其他类加载器的父加载器，它位于类加载器层次结构的顶端，并没有一个具体的Java类来表示它。由于启动类加载器是虚拟机的一部分，它并不受Java应用程序的控制，也无法在Java代码中直接获取。</span></p><p><span>启动类加载器的加载路径包括虚拟机的系统属性</span><code>sun.boot.class.path</code><span>所指定的路径，通常包含了JRE中的核心类库，例如</span><code>rt.jar</code><span>。</span></p><p><span>启动类加载器的主要特点如下：</span></p><ol start='' ><li><span>最顶层的类加载器：它没有父类加载器，是类加载器层次结构的起点。</span></li><li><span>由C++实现：启动类加载器是虚拟机的一部分，通常用C++编写，不受Java应用程序的影响。</span></li><li><span>加载核心类库：负责加载Java核心类库，这些类库是Java虚拟机运行时所必需的。</span></li></ol><p><span>由于启动类加载器是虚拟机的一部分，它与其他类加载器不同，不遵循双亲委派模型。其他类加载器在加载类时，会优先将类加载请求委派给父类加载器，只有在父类加载器无法加载时，才会尝试自己加载。而启动类加载器没有父类加载器，所以它是唯一可以不遵循双亲委派模型的类加载器。</span></p><p><span>由于启动类加载器加载的类是虚拟机运行时必需的类，它们在Java应用程序中是无法被修改或替换的。这些类提供了Java虚拟机的基本功能和核心API，如</span><code>Object</code><span>、</span><code>String</code><span>、</span><code>Class</code><span>等，它们在Java平台的开发和运行过程中扮演着非常重要的角色。</span></p><h2 id='2java内存模型与线程'><span>2、Java内存模型与线程</span></h2><h3 id='java内存模型'><span>Java内存模型</span></h3><p><span>Java内存模型（Java Memory Model，简称JMM）定义了Java程序中多线程并发访问共享内存的行为规范。它规定了线程如何与主内存和工作内存交互，以及如何保证线程间的可见性、有序性和原子性。</span></p><p><span>Java内存模型的主要目标是提供一种统一的、平台无关的内存模型，使得程序员能够正确地编写多线程程序，而不受底层硬件和操作系统的影响。</span></p><p><span>以下是Java内存模型的关键概念：</span></p><ol start='' ><li><strong><span>主内存</span></strong><span>（Main Memory）：主内存是Java虚拟机对应的物理内存，所有线程共享主内存。主内存存储了所有的类、实例变量和静态变量等数据。</span></li><li><strong><span>工作内存</span></strong><span>（Working Memory）：每个线程都有自己的工作内存，它是线程独立的，存储了线程执行过程中使用到的变量副本和部分主内存的数据拷贝。</span></li><li><span>内存间交互操作：线程之间通过主内存进行通信和数据交换。当线程要读取或修改变量时，首先将变量从主内存复制到工作内存，然后进行操作。操作完成后，将结果写回主内存。</span></li><li><span>原子操作（Atomic Operation）：不可被中断的单个操作，要么完全执行成功，要么完全不执行。Java中的原子操作包括基本数据类型的读取和赋值。</span></li><li><strong><span>可见性</span></strong><span>（Visibility）：一个线程对共享变量的修改，能够被其他线程及时地看到。JMM通过内存屏障和缓存一致性协议来保证可见性。</span></li><li><strong><span>有序性</span></strong><span>（Ordering）：Java内存模型不保证线程执行的顺序与程序代码的顺序一致。通过内存屏障和指令重排序来保证线程执行的有序性。</span></li><li><strong><span>Happens-Before关系：</span></strong><span>Happens-Before是Java内存模型中的一个重要概念，它定义了程序中的操作顺序，确定了数据的可见性和有序性。如果一个操作Happens-Before另一个操作，那么第一个操作的结果对第二个操作可见，并且第一个操作的顺序在第二个操作之前。</span></li></ol><p><span>Java内存模型通过对线程之间的数据交互和操作顺序的规范，提供了一致的并发编程模型。程序员可以利用Java内存模型的规则，正确地编写多线程程序，并在多核、多线程的环境下实现正确和高效的并发操作。</span></p><h2 id='3java与线程'><span>3、Java与线程</span></h2><p><span>Java提供了强大的多线程支持，使得开发者能够编写并发和并行的程序。在Java中，线程是独立执行的轻量级任务单元，它可以并发执行，使得程序能够同时执行多个任务。</span></p><p><span>以下是Java中与线程相关的重要概念和类：</span></p><ol start='' ><li><span>Thread类：Java中的线程由Thread类表示。通过继承Thread类或实现Runnable接口，可以创建线程对象，并重写run()方法定义线程的执行逻辑。</span></li><li><span>创建线程：可以通过创建Thread类的实例或实现Runnable接口并传递给Thread类的构造函数来创建线程。然后调用线程对象的start()方法来启动线程。</span></li><li><span>线程生命周期：Java线程具有生命周期，包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和终止（Terminated）等状态。线程可以在这些状态之间切换。</span></li><li><span>线程调度：Java的线程调度由Java虚拟机负责。调度器决定了哪个线程可以运行，并在多个线程之间分配CPU时间。线程的调度可以通过线程的优先级、线程等待和唤醒机制来控制。</span></li><li><span>同步与互斥：Java提供了synchronized关键字和锁对象来实现线程间的同步与互斥。这可以避免多个线程同时访问共享资源，保证数据的一致性和线程的安全性。</span></li><li><span>线程通信：Java提供了wait()、notify()和notifyAll()等方法，用于线程间的通信和协调。线程可以通过这些方法等待其他线程的通知或唤醒其他线程。</span></li><li><span>并发集合类：Java提供了一系列线程安全的并发集合类，如ConcurrentHashMap、ConcurrentLinkedQueue等，用于在多线程环境下进行安全的数据操作。</span></li><li><span>线程池：Java的线程池机制可以重用线程，避免频繁地创建和销毁线程，提高性能和资源利用率。可以通过Executor框架来创建和管理线程池。</span></li></ol><p><span>使用多线程可以提高程序的性能和响应性，充分利用多核处理器的优势。但同时也需要注意线程安全性、竞态条件和死锁等并发编程中的常见问题。编写高效、安全和可靠的多线程程序需要仔细考虑线程同步、共享数据的访问控制和线程间的协作。</span></p><p>&nbsp;</p></div></div>
</body>
</html>